[{"content":"\n\n对于喜欢vim的同学们，在写代码的时候可能遇到一些不是太方便的事情，例如创建一个文件，在正常的IDE中都会创建一个头注释，作为说明，这块在VIM也是可以实现的\n\n\n\n```\n\"SET Comment START\nautocmd BufNewFile *.php,*.js,*.cpp exec \":call SetComment()\" |normal 10Go\nfunc SetComment()\n    if expand(\"%:e\") == 'php'\n        call setline(1, \"\u003c?php\")\n    elseif expand(\"%:e\") == 'js'\n        call setline(1, '//JavaScript file')\n    elseif expand(\"%:e\") == 'cpp'\n        call setline(1, '//C++ file')\n    endif\n    call append(1, '/**')\n    call append(2, ' * Create by YourName')\n    call append(3, ' * Mail: YourName@XXX.com')\n    call append(4, ' * Date: '.strftime(\"%Y-%m-%d\"))\n    call append(5, ' * Time: '.strftime(\"%H:%M:%S\"))\n    call append(6, ' */')\n\"    call append(7, '')\nendfunc\n```\n\n\n在创建文件的时候支持三种类型，分别是php，js，cpp这三类，如果有需要可以自己行扩展.\n","cover":"","link":"vim文件头注释.html","preview":"\u003cp\u003e对于喜欢vim的同学们，在写代码的时候可能遇到一些不是太方便的事情，例如创建一个文件，在正常的IDE中都会创建一个头注释，作为说明，这块在VIM也是可以实现的\u003c/p\u003e\n","title":"VIM 文件头注释"},{"content":"\n\n## 关于新年的心得\n\n转眼间，一年过去了，这一年发生了很多，离开了学校，走向了社会，也结束了实习生活，开始了一个上班族的日常生活。在毕业后的这半年里，很开心，很放肆，就这样过了半年，在跨年的时候，回望整个2017年，我发现，这半年我一直浮于世事, 未曾深刻的思考过未来应该怎么做？未来的路该怎么走？未来想成为什么样的人？也未曾思考过如何去继续和努力。\n\n\n\n在半年的工作里，收获了很多，见识了很多，了解了很多，但是却发现，丢失了一点--沉稳，心变得浮躁了，浮躁的接受新事物的速度很慢，学习速度很慢，自由写代码的时间少了，回望着半年的收获，总觉得自己的失去大于收获。\n\n希望在未来的一年里，能够沉得住气，快速而稳健的成长和进步。\n","cover":"","link":"2017-2018.html","preview":"\u003ch2\u003e关于新年的心得\u003c/h2\u003e\n\n\u003cp\u003e转眼间，一年过去了，这一年发生了很多，离开了学校，走向了社会，也结束了实习生活，开始了一个上班族的日常生活。在毕业后的这半年里，很开心，很放肆，就这样过了半年，在跨年的时候，回望整个2017年，我发现，这半年我一直浮于世事, 未曾深刻的思考过未来应该怎么做？未来的路该怎么走？未来想成为什么样的人？也未曾思考过如何去继续和努力。\u003c/p\u003e\n","title":"2017-2018"},{"content":"\n\n随着网站流量上升，服务的负载不堪重负。造成崩溃问题。\n\n对此，有两种解决方法，首先，第一种，升级服务器，购买更高的配置的服务器，这种方式简单易行，缺点是投资比较大，然后流量再次上升，就会面临同样的问题。另一种方法是采用集群技术。采用两台以上的服务器进行协同工作（集群系统中的服务器不一定非得是高性能的服务器，但是可以提供高性能的不停机服务，随着需求的增加，可以在集群追加服务器），集群的优点是高可靠性，和强大灵活的系统扩展能力。\n\n\n\n两台以上的服务器协同工作必然涉及到负载均衡，常用的负载均衡技术有NAT负载均衡，反向代理负载均衡，DNS负载均衡。NAT负载均衡是将外部的IP地址映射为多个内部的IP地址，对每次请求连接动态的转换为内部服务器的ip地址，对外部服务器的访问也转接到这个内部服务器上。\n\n反向代理负载均衡是使用代理服务器，将请求均匀的转发给多台内部服务器之一上。从而达到负载均衡的效果。\n\nDNS负载均衡是在DNS中，为多个地址配置同一个名字，从而使不同的客户，访问不同的服务器来实现负载均衡。DNS的负载均衡是通过循环复用实现的。如果发现主机的多个资源记录，则循环使用包含在查询应答中的主机记录。在默认情况下，DNS服务器的循环复用，对资源记录进行排序，这些资源记录是在解析为多个映射的主机名应答中返回的，该功能提供了一种非常简便的方法，用于对客户机使用web服务器和频繁查询的多宿主计算机的负载均衡。\n\n如果需要使用DNS循环复用，则首先在该区域内注册所查询名称的多个主机资源记录，并启用DNS循环复用，如果禁用DNS循环复用，那么这些查询的响应顺序以应答列表中资源记录在区域中存储时的静态排序为基础。\n\n需要注意的两点：\n\n当集群服务器不在同一个网段时，默认情况下。当客户机解析查询到多个ip地址的主机名时，DNS使用本地子网优先排序作为给出同一网络上首选ip的方法，此功能要求客户应用程序尝试使用连接可用的最近的ip的主机到本机。DNS通过以下方式进行子网优先：\n\n        ①DNS 服务确定是否需要本地子网的优先级排序查询响应。\n\t\t　　如果有多个地址资源记录与要查询的主机名匹配，则 DNS 服务可根据其子网位置重新对记录进行排序。如果查询的主机名只与一个 地址资源\n\t\t　　记录匹配，或者客户机的 IP 网络地址与多重资源记录响应列表上的任何映射地址的 IP 网络地址匹配，则不需要进行优先排列。\n\t\t　　②对于匹配响应列表中的每一个资源纪录，DNS 服务决定了哪些记录(如果有)与查询客户机的子网位置匹配。\n\t\t　　③DNS 服务重新对响应列表进行排序，以便将与发出请求的客户机的本地子网匹配的 主机地址资源记录排在响应列表中的第一位。\n\t\t　　④根据子网的顺序进行优先级排序后，响应列表将返回给发出请求的客户机。\n\n不足之处：\n\n\t\t虽然DNS循环复用是负载均衡的普遍解决方法，但是仍然存在缺点。循环复用 DNS 使用 DNS将传入的 IP 请求映射到定义的一系列循环形式的服务器。一旦发生服务器故障，循环复用 DNS 继续把请求发送到这个故障服务器，一直到把该服务器从 DNS 中移走为止。这样许多用户必须等到 DNS 连接超时以后才能成功地访问目标网站。\n\n\t    集群负载均衡被认为是目前十大热门技术之一，它也是一个高端应用，Internet/Intranet中负载均衡方法应用十分广泛，许多大中型网站都难脱离这种技术。NAT负载均衡、反向代理均衡及DNS负载均衡，将视需要而被采用。利用循环复用DNS实现负载均衡是一种经济又实用的方法，不需要添加昂贵的负载均衡设备，并且服务器可以位于互联网的任意位置，该技术当前使用在包括Yahoo在内的一些Web站点上。\n\n\n","cover":"","link":"dns循环复用.html","preview":"\u003cp\u003e随着网站流量上升，服务的负载不堪重负。造成崩溃问题。\u003c/p\u003e\n\n\u003cp\u003e对此，有两种解决方法，首先，第一种，升级服务器，购买更高的配置的服务器，这种方式简单易行，缺点是投资比较大，然后流量再次上升，就会面临同样的问题。另一种方法是采用集群技术。采用两台以上的服务器进行协同工作（集群系统中的服务器不一定非得是高性能的服务器，但是可以提供高性能的不停机服务，随着需求的增加，可以在集群追加服务器），集群的优点是高可靠性，和强大灵活的系统扩展能力。\u003c/p\u003e\n","title":"DNS循环复用"},{"content":"\n\n\n在工作中开发，用fis3的上传工具，今天在上传过程中产生了一个错误，google之后和我遇到的情况不太一样，我这个情况有点特殊，可能之后有朋友可能会遇到，所以记录下来。\n\n\n\n```\n/usr/local/lib/node_modules/fis3/node_modules/fis3-deploy-http-push/index.js:228\n        throw new Error(error.errmsg || error);\n        ^\nError: upload file [/actions/activity/v1/AcceptInvite.php] to [/home/homework/app/course] by receiver [http://test37.zuoyebang.cc/fisreceiver.php] error [500]\nat /usr/local/lib/node_modules/fis3/node_modules/fis3-deploy-http-push/index.js:228:19\nat /usr/local/lib/node_modules/fis3/node_modules/fis3-deploy-http-push/index.js:26:11\nat IncomingMessage.\u003canonymous\u003e (/usr/local/lib/node_modules/fis3/lib/util.js:1263:11)\nat emitNone (events.js:91:20)\nat IncomingMessage.emit (events.js:185:7)\nat endReadableNT (_stream_readable.js:974:12)\nat _combinedTickCallback (internal/process/next_tick.js:80:11)\nat process._tickCallback (internal/process/next_tick.js:104:9)\n```\n\n遇到这个问题，http 提示状态码 是 500 ，这块首先看看服务器接收文件有没有问题，检查上传文件是否可访问，检查被上传文件目录是否有权限，如果这些都没问题，你可能遇到了和我同样的问题（这种概率不大\n\n```\ncurl http://test.***.cc/fisreceiver.php\nI'm ready for that, you know.\n```\n\n反馈是正常的，所以应该不是程序的问题，然后我去检查nginx的日志，发现没有日志，这就很奇怪了。\n\n```\ndf -h \n```\n\n看了一下文件系统，满了。。。找到问题的关键了，所以遇到我得这种情况的概率很低，但是如果有朋友遇到这种情况，不妨考虑一下我这个解决思路。\n","cover":"","link":"fis3上传错误.html","preview":"\u003cp\u003e在工作中开发，用fis3的上传工具，今天在上传过程中产生了一个错误，google之后和我遇到的情况不太一样，我这个情况有点特殊，可能之后有朋友可能会遇到，所以记录下来。\u003c/p\u003e\n","title":"fis3上传错误"},{"content":"\n\n安装composer中，提示缺少一些扩展，php -m查询，果然缺少，但是发现phpinfo中都有啊。\n\n\n\n卧槽！卧槽！卧槽！什么情况！\n\n经过一番搜索，发现php cli模式下的配置文件和web下的配置文件不是一个（好low，才知道）。。。\n\nphp --ini 可以查看cli模式下的配置文件路径。\n\n```\nroot@ubuntu:/home/ubuntu# php --ini\nConfiguration File (php.ini) Path: /etc/php/7.0/cli\nLoaded Configuration File:         (none)\nScan for additional .ini files in: /etc/php/7.0/cli/conf.d\nAdditional .ini files parsed:      (none)\n```\n\n我猜测了一下，大致是说cli下的配置文件，是在/etc/php/7.0/cli目录下，但是下面那行的loaded Configuration File是none，说明没有啊，于是就在对应的目录下创建了文件。写了个空的php-cli.ini\n\n再次php --ini发现loaded Configuration File有了！！！有了！！！\n\nbut发现了一个事。报错。。\n\n```\nPHP Warning:  PHP Startup: Invalid library (maybe not a PHP library) '/usr/local/php7/ext/json.so' in Unknown on line 0\n```\n\n先抱着试试看的态度php -m一下。。果然！！！没有！！！\n\n然后开始纠结新的问题。为啥会报错呢。。。\n\n采用了最古老的办法，复制问题，浏览器粘贴，在stackOverflow中发现了我想要的答案，过滤到大量无效（不认识）的英文，发现了我想要的答案。\n\n```\nNot sure what caused this, but make clean then restarting phpize \u0026\u0026 ./configure \u0026\u0026 make \u0026\u0026 make install solved this sort of problem.\n```\n\n就是上面这句话。他说他不懂咋回事，但是执行make clean然后接着编译别的插件一个流程就行了。\n\n虽然我也不懂，但是又抱着试试看的态度执行了一遍。\n\n可以用了！！！\n\n貌似好像是缓存的因素。\n\n以上文章仅是个人猜测和实验。如有错误~求指点！！！\n","cover":"","link":"phpinfo中存在cli模式下不存在的模块.html","preview":"\u003cp\u003e安装composer中，提示缺少一些扩展，php -m查询，果然缺少，但是发现phpinfo中都有啊。\u003c/p\u003e\n","title":"php -m 不存在的模块，phpinfo中存在"},{"content":"\n\n关于扩展安装这块的步骤，单纯记录，大佬忽略。\n\n首先要下载mongodb的php扩展。\n\n\n\n```\nwget https://pecl.php.net/get/mongodb-1.1.1.tgz  \n\n// 接着解压并进入该文件夹 \n\ntar -zxvf ./mongodb-1.1.1.tgz \u0026\u0026 cd mongodb-1.1.1\n```\n\n接着就直接和其他的编译扩展是一个类型了。\n\n```\n// 路径自己替换一下，找到自己的phpize 和php-config就好\n\n/usr/local/php7/bin/phpize \u0026\u0026 ./configure --with-php-config=/usr/local/php7/bin/php-config\n\n// 然后把生成的mongodb.so复制到相应的位置。在php.ini中写入\n\nextension = mongodb.so;\n```\n\n然后重启php-fpm。访问php_info，显示已经安装了相应的扩展。\n\n\n","cover":"","link":"php7编译安装mongodb扩展.html","preview":"\u003cp\u003e关于扩展安装这块的步骤，单纯记录，大佬忽略。\u003c/p\u003e\n\n\u003cp\u003e首先要下载mongodb的php扩展。\u003c/p\u003e\n","title":"php7编译安装mongodb扩展"},{"content":"\n\n最近在学习yaf，装上yaf后，正常访问路径出错。因为是404，所以确定是nginx的重写规则问题，在google、百度了之后，看到网上的很多教程说鸟哥的手册写错了。\n\n\n\n```\nif (!-e $request_filename) {\n    rewrite ^/(.*)  /index.php/$1 last;\n  }\n\n// 把index.php 后面的/ 换成 ？ 变成如下：\n\nif (!-e $request_filename) {\n    rewrite ^/(.*)  /index.php?$1 last;\n}\n```\n\n尝试之后发现可以，因为公司用的重写规则就是 / 而不是 ？，更觉得不可能是鸟哥文档出错了呀。所以去查找了相关资料。\n\n发现，之所以使用url模式访问的时候，第一种的重写规则并没有起作用，也就是说访问的正常路径没有传到index.php（当然这是一种错误的思想，不过开始是这么想的）。接着又去查找资料，发现了tp的同样的重写规则的原理，发现tp是获取$_SERVER['PATH_INFO']这个变量。然后分割，然后去尝试在yaf下var_dump这个变量， NULL，果然出错，猜想或许yaf同样的用了同样的原理。于是搜索为什么没有这个变量，和nginx相关联后，发现$_SERVER这个服务器环境变量可以被nginx干预，也就是在nginx处理的时候，会从fastcgi传过来。接着搜索nginx的配置文件，发现了fastcgi的传到server的参数。\n\n```\nfastcgi_param  QUERY_STRING       $query_string;\nfastcgi_param  REQUEST_METHOD     $request_method;\nfastcgi_param  CONTENT_TYPE       $content_type;\nfastcgi_param  CONTENT_LENGTH     $content_length;\n\nfastcgi_param  SCRIPT_NAME        $fastcgi_script_name;\nfastcgi_param  REQUEST_URI        $request_uri;\nfastcgi_param  DOCUMENT_URI       $document_uri;\nfastcgi_param  DOCUMENT_ROOT      $document_root;\nfastcgi_param  SERVER_PROTOCOL    $server_protocol;\nfastcgi_param  REQUEST_SCHEME     $scheme;\nfastcgi_param  HTTPS              $https if_not_empty;\n\nfastcgi_param  GATEWAY_INTERFACE  CGI/1.1;\nfastcgi_param  SERVER_SOFTWARE    nginx/$nginx_version;\n\nfastcgi_param  REMOTE_ADDR        $remote_addr;\nfastcgi_param  REMOTE_PORT        $remote_port;\nfastcgi_param  SERVER_ADDR        $server_addr;\nfastcgi_param  SERVER_PORT        $server_port;\nfastcgi_param  SERVER_NAME        $server_name;\n\n# PHP only, required if PHP was built with --enable-force-cgi-redirect\nfastcgi_param  REDIRECT_STATUS    200;\n```\n\n然后并没有发现PATH_INFO，所以基本上已经接近真相了。\n\n然后去得到的现在的条件去查找，得到了下面的语句：\n\n```\nfastcgi_split_path_info ^(.+?\\.php)(/.*)$;\nset $path_info $fastcgi_path_info;\nfastcgi_param PATH_INFO       $path_info;\ntry_files $fastcgi_script_name =404;\n```\n\n构造path_info 并传过去。果然传过去之后，立刻就可以了。\n","cover":"","link":"yaf-nginx重写规则.html","preview":"\u003cp\u003e最近在学习yaf，装上yaf后，正常访问路径出错。因为是404，所以确定是nginx的重写规则问题，在google、百度了之后，看到网上的很多教程说鸟哥的手册写错了。\u003c/p\u003e\n","title":"yaf nginx重写规则"},{"content":"\n\n安装yaf，yaf是鸟哥开发的一个扩展类型的php框架，框架是用c写的，所以性能会比一般的框架性能好一些。\n\n首先是下载\n\n\n\n```\nwget http://pecl.php.net/get/yaf-2.2.9.tgz \u0026\u0026 tar zxvf yaf-2.2.9.tgz \u0026\u0026 cd yaf-2.2.9\n```\n\n下载打开目录后，编译安装\n\n```\n/usr/local/php/bin/phpize  \u0026\u0026 ./configure --with-php-config=/usr/local/php/bin/php-config \u0026\u0026 make \u0026\u0026 make install\n```\n\n如果出现下面这句话，说明这yaf安装成功了。\n\n```\nInstalling shared extensions: /usr/local/php/lib/php/extensions/no-debug-non-zts-20121212/\n```\n\n然后修改php.ini 添加yaf的扩展\n\n```\nextension_dir = \"/usr/local/php/modules\"\n\n[yaf]\nyaf.environ = product\nyaf.library = NULL\nyaf.cache_config = 0\nyaf.name_suffix = 1\nyaf.name_separator = \"\"\nyaf.forward_limit = 5\nyaf.use_namespace = 0\nyaf.use_spl_autoload = 0\nextension=yaf.so //核心配置是yaf.so模块\n\n```\n\nlnmp reload 重启环境后查看phpinfo，如果有yaf的扩展，则安装成功。\n\n打开github.com/laruence/php-yaf。下载github上的代码。\n\n然后打开目录中的tools/cg\n\n```\n/usr/local/php/bin/php yaf_cg yaf_app\n```\n\n如果在安装过程中出现DONE，则安装成功，如果存在phpwarning，是因为php.ini中的有些函数被禁用。找到disable_functions，去掉被禁止的函数就好。\n\n重新输入上面的代码，则输出DONE。接着output中的yaf_app拷贝到环境目录，访问出现Hello World! I am Stranger, 则成功！\n","cover":"","link":"yaf安装.html","preview":"\u003cp\u003e安装yaf，yaf是鸟哥开发的一个扩展类型的php框架，框架是用c写的，所以性能会比一般的框架性能好一些。\u003c/p\u003e\n\n\u003cp\u003e首先是下载\u003c/p\u003e\n","title":"yaf安装"},{"content":"\n\n在Ubuntu下编译安装nginx，首先去下载nginx的安装包。\n\nhttp://nginx.org/en/download.html\n\n下载对应的压缩包后，解压。执行命令编译安装\n\n\n\n```\ntar -zxvf ./nginx-1.10.1.tar.gz\ncd nginx-1.10\n\n./configure --prefix=/usr/local/nginx\n\n#这时候出现了第一个问题\n\n./configure: error: the HTTP rewrite module requires the PCRE library.\nYou can either disable the module by using --without-http_rewrite_module\noption, or install the PCRE library into the system, or build the PCRE library\nstatically from the source with nginx by using --with-pcre=\u003cpath\u003e option.\n```\n\n此时需要安装pcre这个插件，本企图手动编译这个插件，无奈多次都失败，有大神知道的话，还请评论解答。\n\n使用ubuntu的依赖安装\n\n```\nsudo apt-get install libpcre3 libpcre3-dev \n\n#这时出现了第二个问题\n\n./configure: error: the HTTP gzip module requires the zlib library.\nYou can either disable the module by using --without-http_gzip_module\noption, or install the zlib library into the system, or build the zlib library\nstatically from the source with nginx by using --with-zlib=\u003cpath\u003e option.\n```\n\n此时需要安装zlib插件，手动编译失败后，转向ubuntu的依赖安装\n\n```\nsudo apt-get install zlib1g-dev\n\n#接下来就是编译安装\n\n./configure --prefix=/usr/local/nginx\n\nmake\n\nmake install\n```\n\n","cover":"","link":"编译安装nginx.html","preview":"\u003cp\u003e在Ubuntu下编译安装nginx，首先去下载nginx的安装包。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://nginx.org/en/download.html\"\u003ehttp://nginx.org/en/download.html\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e下载对应的压缩包后，解压。执行命令编译安装\u003c/p\u003e\n","title":"编译安装nginx"},{"content":"\n\nUbuntu16.04 安装ftp，根据依赖安装。\n\n安装vsftpd。\n\n\n\n```\nsudo apt-get install vsftpd\n```\n\n结束后则安装完毕。\n\n配置vsftpd。\n\n```\n// 打开编辑文件\nsudo vi /etc/vsftpd.conf\n\n// 设置本地账户可以以ftp账户登录\nlocal_enable=YES\n\n// 使用用户的本地账户目录作为ftp目录 \nchroot_local_user=YES \n\n// 允许用户上传文件\nwrite_enable=YES \n\n// 修改完成后保存并重启vsftpd \nsudo /etc/init.d/vsftpd restart \n\n// 添加ftp使用用户\nsudo useradd -d /home/ftp_testuser -m ftp_testuser \n// 设置账户密码\nsudo passwd ftp_testuser \n```\n","cover":"","link":"ubuntu16.04安装ftp.html","preview":"\u003cp\u003eUbuntu16.04 安装ftp，根据依赖安装。\u003c/p\u003e\n\n\u003cp\u003e安装vsftpd。\u003c/p\u003e\n","title":"Ubuntu16.04 安装ftp"},{"content":"\n\n方便开发过程中简单写简单的函数\n\n\n\n```\n\tpublic function page($total, $p){\n        $pageNum = 5;\n        $p = $p \u003c 1 ? 1 : $p;\n        $p = $p \u003e $total ? $total : $p;\n        $total = $total \u003c $p ? $p : $total;\n\n        // 计算开始页\n        $start = $p - floor($pageNum / 2);\n        $start = $start \u003c 1 ? 1 : $start;\n\n        // 计算结束页\n        $end = $p + floor($pageNum /2);\n        $end = $p \u003e= $total ? $total : $end;\n\n        $current = $end - $start + 1;\n        // 左调整\n        if ($current \u003c $pageNum \u0026\u0026 $start \u003e 1){\n            $start = $start - ($pageNum-$current);\n            $start = $start\u003c1 ? 1 : $start;\n            $current = $end-$start+1;\n        }\n        // 右边调整\n        if($current\u003c$pageNum \u0026\u0026 $end\u003c$total){\n            $end = $end + ($pageNum-$current);\n            $end = $end\u003e$total? $total : $end;\n        }\n\n        $output = '';\n        if ($p \u003e 1){\n            $output .= '\u003ca href=\"/tv/bang/tv_list.php?p=1\" title=\"第一页\"\u003e\u003c\u003c\u003c/a\u003e';\n        }\n        for ($i = $start; $i \u003c= $end; $i++){\n            if ($i == $p){\n                $output .= '\u003ca href=\"javascript:void(0)\" class=\"current\"\u003e'.$i.'\u003c/a\u003e';\n            }else{\n                $output .= '\u003ca href=\"/tv/bang/tv_list.php?p='.$i.'\"\u003e'.$i.'\u003c/a\u003e';\n            }\n        }\n\n        if ($p \u003c $end){\n            $output .= '\u003ca href=\"/tv/bang/tv_list.php?p='.$total.'\" title=\"第一页\"\u003e\u003e\u003e\u003c/a\u003e';\n        }\n        $this-\u003eoutput['pages'] = $output;\n\n    }\n```\n","cover":"","link":"php分页函数.html","preview":"\u003cp\u003e方便开发过程中简单写简单的函数\u003c/p\u003e\n","title":"php分页函数"},{"content":"\n\njs封装分页类,第一次这么写，求指正\n\n\n\n```\n/*javascript 分页*/\n    (function(win, list){\n\n        win.page = {\n            _list : '',\n            pageCount   : 0,    // 所有数据的总数\n            singleNum   : 2,    // 每页显示的条数,默认为10\n            pageNum     : 0,    // 页数\n            currentPage : 1,\n            /**\n             * 初始化数据\n             */\n            init : function(){\n\n                this._list = this.toArray(list);\n                this.calculatePage();\n\n                this.getData();\n                this.pageClick();\n            },\n            /**\n             * 将传入的json对象转化为数组\n             * @param list\n             * @returns {Array}\n             */\n            toArray : function(list){\n                var listArr = new Array();\n\n                for (var i in list)\n                    listArr.push(list[i]);\n\n                return listArr;\n            },\n            /**\n             * 计算页码\n             * @returns {*}\n             */\n            calculatePage : function(){\n                this.pageCount = this._list.length;\n\n                if (this.pageCount == 0){\n                    return fales;\n                }\n\n                this.pageNum = Math.ceil(this.pageCount / this.singleNum);\n            },\n            /**\n             * 获取hash值中的页码\n             * @returns {Number}\n             */\n            gethash : function(){\n                return parseInt(window.location.hash.substr(2));\n            },\n            /**\n             * 分割要渲染的数据\n             */\n            getData : function(){\n                this.currentPage = this.gethash()?this.gethash():1;\n\n                if (this.currentPage \u003e this.pageNum){\n                    this.currentPage = this.pageNum;\n                }\n\n                var start   = (this.currentPage - 1) * this.singleNum;\n                var end     = this.currentPage * this.singleNum;\n\n                var renderData = this._list.slice(start, end);\n                this.renderPage(renderData);\n            },\n            /**\n             * 渲染数据到页面表格中\n             * @param data\n             */\n            renderPage : function (data) {\n                var str = '';\n                for(var i = 0; i \u003c data.length; i++){\n                    // '\u003ctd\u003e'+data[i].scheme+'\u003c/td\u003e'+\n                    // '\u003ctd\u003e'+data[i].http+'\u003c/td\u003e'+\n                    str +=  '\u003ctr\u003e\u003ctd\u003e'+data[i].id+'\u003c/td\u003e'+\n                            '\u003ctd\u003e'+data[i].name+'\u003c/td\u003e'+\n                            '\u003ctd\u003e'+data[i].edit_time+'\u003c/td\u003e'+\n                            '\u003ctd\u003e'+data[i].edit_user+'\u003c/td\u003e\u003ctd\u003e';\n                    if(data[i].status == 0){\n                        str +=  '未发布\u003c/td\u003e\u003ctd\u003e' +\n                                '\u003ca href=\"javascript:void(0)\" data-id=\"'+data[i].id+'\" data-status=\"1\" class=\"edit_status\"\u003e发布\u003c/a\u003e';\n                    }else{\n                        str +=  '已发布\u003c/td\u003e\u003ctd\u003e' +\n                                '\u003ca href=\"javascript:void(0)\" data-id=\"'+data[i].id+'\" data-status=\"0\" class=\"edit_status\"\u003e下线\u003c/a\u003e';\n                    }\n                    str += '\u0026nbsp;\u0026nbsp;\u003ca href=\"/tv/bang/edit_subject.php?id='+data[i].id+'\"\u003e编辑\u003c/a\u003e\u003c/td\u003e\u003c/tr\u003e';\n                    $('#subject_list').html(str);\n                }\n                this.renderPageNum();\n                console.log(data);\n            },\n            /**\n             * 渲染底部页码\n             */\n            renderPageNum : function (){\n                if (this.pageNum == 1){\n                    return ;\n                }\n                var pageStr = '';\n                for (var j=1; j \u003c= this.pageNum; j++){\n                    if (j == this.currentPage){\n                        pageStr += '\u003ca href=\"javascript:void(0)\" class=\"current\"\u003e'+j+'\u003c/a\u003e';\n                    }else{\n                        pageStr += '\u003ca href=\"#p'+j+'\"\u003e'+j+'\u003c/a\u003e';\n                    }\n                }\n                $('.page_selector').html(pageStr);\n            },\n            /**\n             * 页码点击监控\n             */\n            pageClick : function (){\n                $('.page_selector a').live('click',function () {\n                    window.location.reload();\n                });\n            }\n\n        };\n        // var pageCount = list.length();\n\n        page.init();\n    })(window, window.subject_list);\n```\n","cover":"","link":"js封装分页类.html","preview":"\u003cp\u003ejs封装分页类,第一次这么写，求指正\u003c/p\u003e\n","title":"封装分页类"},{"content":"\n\n一、带零\necho date('Y-m-d');\n\n2012-08-08\n\n\n\n二、不带零\necho date('Y-n-j');\n\n2012-8-8\n\n \n\n 以下为参数详解（转载）：\n\n a - \"am\" 或是 \"pm\"\n\n A - \"AM\" 或是 \"PM\"\n\n d - 几日，二位数字，若不足二位则前面补零; 如: \"01\" 至 \"31\"\n\n D - 星期几，三个英文字母; 如: \"Fri\"\n\n F - 月份，英文全名; 如: \"January\"\n\n h - 12 小时制的小时; 如: \"01\" 至 \"12\"\n\n H - 24 小时制的小时; 如: \"00\" 至 \"23\"\n\n g - 12 小时制的小时，不足二位不补零; 如: \"1\" 至 12\"\n\n G - 24 小时制的小时，不足二位不补零; 如: \"0\" 至 \"23\"\n\n i - 分钟; 如: \"00\" 至 \"59\"\n\n j - 几日，二位数字，若不足二位不补零; 如: \"1\" 至 \"31\"\n\n l - 星期几，英文全名; 如: \"Friday\"\n\n m - 月份，二位数字，若不足二位则在前面补零; 如: \"01\" 至 \"12\"\n\n n - 月份，二位数字，若不足二位则不补零; 如: \"1\" 至 \"12\"\n\n M - 月份，三个英文字母; 如: \"Jan\"\n\n s - 秒; 如: \"00\" 至 \"59\"\n\n S - 字尾加英文序数，二个英文字母; 如: \"th\"，\"nd\"\n\n t - 指定月份的天数; 如: \"28\" 至 \"31\"\n\n U - 总秒数\n\n w - 数字型的星期几，如: \"0\" (星期日) 至 \"6\" (星期六)\n\n Y - 年，四位数字; 如: \"1999\"\n\n y - 年，二位数字; 如: \"99\"\n\n z - 一年中的第几天; 如: \"0\" 至 \"365\"\n\n\n","cover":"","link":"date函数详解.html","preview":"\u003cp\u003e一、带零\necho date(\u0026lsquo;Y-m-d\u0026rsquo;);\u003c/p\u003e\n\n\u003cp\u003e2012-08-08\u003c/p\u003e\n","title":"date函数详解"},{"content":"\n\n创建单链表并逆置\n\n\n\n```\n//\n//  main.c\n//  newline\n//\n//  Created by Jason on 16/4/12.\n//  Copyright © 2016年 jason. All rights reserved.\n//\n\n#include \u003cstdio.h\u003e\n#include \"stdlib.h\"\n#define NULL 0\n\nstruct node{\n    int data;\n    struct node *next;\n};\nstruct node*create(struct node *L){\n   \n    int x, flg = 1;\n    struct node *p, *s;\n    L=(struct node *)malloc(sizeof(struct node)); //生成头结点\n    L-\u003enext = NULL;\n    p=L;\n    while(flg)    //循环接受输入节点数据，0结束输入\n    {\n        printf(\"请输入节点数据\\n\");\n        scanf(\"%d\", \u0026x);\n        if(x != 0)\n        {\n            s=(struct node *)malloc(sizeof(struct node)); //生成新节点\n            s-\u003edata = x;\n            p-\u003enext = s;        //把新节点插入链表尾部\n            p = s;              //p指针再次指向尾节点\n        }\n        else\n        {\n            flg = 0;    //输入0，改变循环变量，不接受新节点\n        }\n        \n    }\n    p-\u003enext = NULL;\n    \n    puts(\"链表输入结束\\n\");\n    \n    return L;\n}\nvoid print_node(struct node *head){\n    struct node *tmp;\n    tmp = head-\u003enext;\n    while (tmp != NULL) {\n        printf(\"%d  \", tmp-\u003edata);\n        tmp = tmp-\u003enext;\n    }\n}\nvoid reverse_node(struct node *head){\n    struct node *p1,*p2;\n    p1 = head-\u003enext;\n    head-\u003enext = NULL;\n    while (p1 != NULL) {\n        p2 = p1;\n        p1 = p1-\u003enext;\n        p2-\u003enext = head-\u003enext;\n        head-\u003enext = p2;\n    }\n\n}\nint main(int argc, const char * argv[]) {\n    \n    struct node *head;\n    head = NULL;\n    head=create(head);/*创建单链表*/\n    puts(\"\\n所有链表:\\n\");\n    print_node(head);\n    puts(\"\\n\");\n    puts(\"链表逆置:\\n\");\n    reverse_node(head);\n    print_node(head);\n    return 0;\n}\n```\n","cover":"","link":"链表的逆置.html","preview":"\u003cp\u003e创建单链表并逆置\u003c/p\u003e\n","title":"链表的逆置"},{"content":"\n\n最近做的项目里面有用到session 共享\n\n代码是这样的，session_start() 之前，写入这个代码。 将test.com 换成你的顶级域名，我在工作中，使用了thinkphp ，我在入口文件中加入了这三行代码，亲测可行，原生php写的demo也可以用，据说在thinkphp的config文件里写也可以（未测）：\n\n\n\n```\nini_set('session.cookie_path', '/');\nini_set('session.cookie_domain', 'test.com');\nini_set('session.cookie_lifetime', '1800');\n```\n\n关于这个问题研究了一下，做个记录，方便大家查询：\n\n先说一下sessionid ,sessionid 是随机生成的，是服务器端session的文件名称。\n\nsession 是保存在服务器端的文件，而会在客户端浏览器留下一个 sessionid ,方便区分用户，在使用的时候用本地的sessionid 去服务端寻找session文件。\n\n\n\n如果说有两个域名，让他们公用一个session文件，首先是，这个session文件，在同一个服务器上面，或者是能同时被两个域名下的程序访问到的地方。\n\n如果说上面的做到了，接下来就是本地浏览器了\n\n本地浏览器将sessionid 以cookie的形式存放。而cookie是以域名的形式区分的，所以只要让 cookie 以顶级域名的形式存放，这个顶级域名和这个顶级域名下的二级域名，都可以获取到这个sessionid。因为上面可以访问到session文件，所以自然拿到sessionid就可以获取到了session\n\n\n以开源中国为例，cookie 下面出现以顶级域名存放的session，则设置共享session成功；\n\n```\nini_set('session.cookie_path', '/');\nini_set('session.cookie_domain', '.test.com');\nini_set('session.cookie_lifetime', '1800');\n\n$ret = array(\n    'name' =\u003e isset($_POST['name'])? $_POST['name'] : '',\n    'gender' =\u003e isset($_POST['gender'])? $_POST['gender'] : ''\n);\n\n$origin = isset($_SERVER['HTTP_ORIGIN'])? $_SERVER['HTTP_ORIGIN'] : '';\n\n$allow_origin = array(\n    'http://www.test.com',\n    'http://aaa.test.com'\n);\n\nif(in_array($origin, $allow_origin)){\n    header('Access-Control-Allow-Origin:'.$origin);\n    header('Access-Control-Allow-Methods:POST');\n    header('Access-Control-Allow-Headers:x-requested-with,content-type');\n}\n```\n\n设置二级域名后，必然伴随着跨域问题，毕竟jsonp不是官方的解决方法\n","cover":"","link":"session跨域.html","preview":"\u003cp\u003e最近做的项目里面有用到session 共享\u003c/p\u003e\n\n\u003cp\u003e代码是这样的，session_start() 之前，写入这个代码。 将test.com 换成你的顶级域名，我在工作中，使用了thinkphp ，我在入口文件中加入了这三行代码，亲测可行，原生php写的demo也可以用，据说在thinkphp的config文件里写也可以（未测）：\u003c/p\u003e\n","title":"session跨域共享session 二级域名之前的共享"},{"content":"\n\n大学时期在V2上遇到的一个大牛给的指点，非常中肯，对于学生时代的我又很大的帮助，非常感谢 v2exer Feiox\n\n\n\n第一部分:\n\n```\n我认识一些深圳、杭州、北京的朋友，他们往往更关注以下内容： \n1. 代码（包括注释）的规范性、可维护性 \n2. 参与一些算法的研究与实现、开源库的创建与维护 \n3. 对新技术的探索，包括但不限于：新框架、新思想、新工具 \n4. 对 Github 上的作品极其认真负责，包括但不限于：良好的 commit 说明，干净的代码（实验性或已注释代码的不会出现在代码库中），以 feature 为单位进行代码提交、分支合并、bug 修复，对 Git 这种工作方式了如指掌。 \n5. 探索多人合作的技巧，并能主动去寻找、求助新的解决方案。 \n6. 对开源社群有深入的理解，知道开源不等于免费，以及知道什么该开源什么不该开源。 \n\n我接触过很多像 LZ 一样的刚毕业大学生，如果 lz 不介意我想提一提我的意见： \n1. LZ 应该关注一下代码规范和设计模式。 \n2. LZ 的作品太过于浅显，并不能体现你的核心竞争力。并且如果着重强调 ThinkPHP 可能会带来减分的效果（在圈子内你多了解一下就知道）。 \n3. 楼主的 “ 熟悉 div+css 布局，可用 jquery 写简单特效，会使用 ajax ” 这有一种《精通CSS+DIV网页样式与布局》这种书的既视感，你可曾了解过 CSS3 Flex Angular.js React.js ？并且，如果你要搞非 MS 系的后端，Linux 是比必备技能，而不是可在 linux 下进行。# 记得刚入学时有个学长在某社团讲座中讲到 PHP 入门，开发环境要 WAMP 不会的来找我，呵呵，你入门为什么不试一试 `php -S \u003cphpfile\u003e` 命令呢? \n4. 我看到 LZ 的 Github 上的代码，提交了很多已注释的代码，如果你的注释有助于他人阅读那是可以的，否则你自己调试的内容不需要让别人知道。另外，你们知道 Git 中的 .gitignore 文件用途么？为什么会出现 ThinkPHP 这个文件夹？再另外，如果你的团队里都是中国人，请使用中文写 commit，并制定团队规范（比如，我们就是采用 行为 + 功能修改 + (可选)涉及 API 变动简述(包含对应文档地址)） \n5. 最好能 在简历中说明你的团队工作经历，表明你已有与人协作的能力。并且能利用 Google StackOverflow 查找英文资料。很多团队很看重这个。 \n6. 对于把 Github 当成团队代码库还不用私有仓库的行为，你们不怕有人看过你们的代码然后让你们的网站挂掉么？用 coding.net 不也免费么。好吧，Github 果然是世界上最大的同性别交友网站，哈哈。但这不是开源。另外，适当使用各自开源工具，可以成倍提升工作效率。 \nP.S. \u003e 你们的代码不写测试么？ \nP.S. \u003e\u003e 大学里打 LOL Dota2 么？ \n\n~ 花了 20 分钟看了你的东西，并写下这些，只为了帮助 LZ 并无恶意请围观朋友勿喷。\n```\n\n第二部分:\n```\n1. 一直不明白为什么现在很多企业要求 PHP 开发者有 HTML CSS JS 能力，现在不是前后端分离了么，这是要全行业招全栈工程师的节奏么。所以，我建议 LZ 应该深入研究一下 计算机网络 操作系统 设计模式 PHP代码优化 数据库等知识，这才是一个后端程序员正道。（对于有志于从事外包行业的同学，可以关本页了 ~ 多说都是泪，那段时间几乎每天要去安慰我那朋友，槽点太多） \n2. 学生时代，大多数人写的最大的项目大概也就是课设、帮老师做外包。所以，对于真正大项目（10w行以上）缺乏（完全没有）了解。对于 MVC 软件架构 设计模式 软件工程 这些名词，完全没有概念。简略说一下我们团队的代码结构，更明确的完全前后分离的 MVC ： \n* 前端：Angular.js + Android + iOS =\u003e 公用一套 RESTful API \n* 后端：（注：以下功能只是重要部分，不是项目根目录下的文件） \n— View 视图：负责生成 API \n—Controller 控制器：复制将各个接口组合起来，传递给 视图 进行数据渲染（格式化后输出 JSON） \n—Handler 处理机：被控制器调用，复制对数据进行加工 \n—Logic 业务：被控制器调用，负责处理业务相关（例如调用其他内部、外部 API 等） \n—Model 数据模型，其中有分以下两个子层： \n—— Data 数据包装层：对数据库相关操作进行封装 \n—— ModelDefine 数据定义层：通过 ODM 或 ORM 进行定义 \n— Lib 工具库：封装各种常用的公共功能，使接口统一易用，如日期格式化、随机数产生、字符串校验 \n— Opt 平台其他软件封装库：封装其他中间件的功能，如 Redis RabbitMQ 等 \n— Dev 开发工具：包括代码强制分析、执行测试、性能分析等等 \n— Test 测试：包含 功能测试、单元测试、集成测试、性能测试等等 \n\n看，实际生产用途的项目是很复杂的。并且我们内部有一个 109 条的强制性规范（Python 的），从代码格式、命名定义、功能分割、基本语法优化等方面限制每个人。这样的好处是每个人的代码都是整洁的，每个模块都是去耦合的，可以分开单独测试。LZ 可晓得测试驱动开发？ \n我是3年前接触的 PHP，在写过一些项目后去年初成为了 PHP 一生黑 （哈哈 ~）但，PHP 很少会对代码进行编译器级的优化（对比 Java 、V8），多人开发大项目时也容易对项目结构失控。并且，由于入手很简单，你可能遇到无数代码写得令人发指的队友（你见过实习生 完全不会 PHP 边学边做边往生产SVN中提交代码 么？外包公司。。。）这还不包括…… \n\n但有人说，这是都是工作之后才可以懂得的，要求大四学生完全熟悉这个是不是过分了？不好意思，我大三就已经从各自 blog 里把这些知识补齐了。这就是我一直说的，我们这些科班出身的和培训班出来的有什么区别？因为我们知道，什么是科学，什么是工程。科学：基本知识的深入理解并可以运用于实际是工程师的基本能力；代码的易读、规范、健壮是必须的，而不是高手才能掌握的。某天，技术领导说我们要利用 TCP 的特点和新出的长连接规范去优化 API 的性能，这时我们不应该傻掉；某天，产品说要加搜索自动补全的功能，我们可以用树型数据结构来很简单实现。敲代码培训几个月谁都会，我女友是学金融的，她还会用 Python 处理计量经济学上的问题呢。 \n所以，我之所以是回答这么多，是因为我看到现在有太多人想通过掉代码获得月薪上万的收入，太多人想通过互联网创业来一夜暴富。敲代码这个行业很有意思，你可以很容易一个人干4个人的活，也很容易被别人问候你全家人 ~ 最近的帖子如证 http://www.v2ex.com/t/211378 \n（写易读的变量名是品德，写注释是美德，写文档是公德，写了易读的变量名有写了注释还写了详细的文档并让我维护你的代码 哦 您是大恩大德） \n\n最后弱弱说一句，希望 LZ 不要不高兴也不要受打击，把自己沉下来，放下 LOL Dota2 每天学习 10 个小时左右，深入学习基础知识。如果想进大公司多学习算法 数据结构 网络 操作系统 方面的知识，如果想进创业团队，学习设计模式、数据库、软件架构，多写一些曲折婉转（大误，其实是高度抽象）的代码，如自己写框架（一定要脱离业务）写 ORM 并完善其文档（这点很重要，在小团队写好文档你队友会爱上你的），这样大四再去工作也不迟。 \n\n科班出身的工程师必备知识：（个人观点欢迎讨论、补充） \n《深入理解计算机系统》《现代操作系统》《计算机网络——自顶向下方法》 \nPHP 高级语法，PHP 代码优化技巧，《代码整洁之道》 \n《深入浅出MySQL：数据库开发、优化与管理维护(第2版)》 \n软件工程 《敏捷开发的艺术》测试驱动开发 RESTful 《大型网站技术架构》 \n完全在 linux 下工作，习惯命令行，并会用各自工具，比如 git docker Vagrant ssh 等等的。 \n使用 PHPStorm Xdebug Composer PHPUnit PHP-CS-Fixer 等 现代化的工具辅助你开发 \n\n（又是半个小时 ~ 哈哈 ~ 欢迎提问） \n~ ~ 其实，我也是山东的 ~ 哈哈\n```\n\n第三部分:\n```\n额，前辈算不算，应该是同龄人吧。我虽然自己业余玩过很多，但谈得上做可以严谨工程项目的大概只有 Python 了。你说的前端是指的 Web 端么，我们也吧 Android iOS 叫前端。Web 的话依我的看法，当下前端开发者应该慢慢学会放下对 jQuery 的依赖，Angular.js 和 React.js 是两种思维很独特的工具，并且适当培养在实际项目中自己的思想（如为什么说“声明式的代码更适合表现 UI 层”这类问题（我们在项目中就使用了很多自实现的声明式的 DSL （SQL 、HTML、CSS 都是应用最广的声明式代码）））。另外，现在的前端开发模式与十年前不同了，分毫不差的完成设计师的图纸是基本要求，但更讲究： \n前后端分离、 \n* 规范化（了解业界规范，如 AMD、REST 等）协作（文档、注释）、 \n* 模块化（无论 UI 还是 JS，都不断抽象形成公共库）、 \n* 工具化（就是使用 node gulp 等工具）、 \n* 敏捷开发（极限开发 TDD BDD 等）、 \n* 新技术（HTML5 ES6 Tyescript）。 \n总体来说，主要还是需要四点能力：1.思考 2.抽象 3. 懒（善用工具）4.学习速度。不过，前端相比后端要简单很多，但优秀的前端工程师却是严重的供小于求的状态（各个创业团队基本都是处于跪求前端的状态，所以我们采用的方式是去 themeforest 购买模板然后套用、修改 T_T）。\n```\n\n非常感谢 v2exer Feiox，感谢你宝贵的时间和经验\n","cover":"","link":"v2ex大牛的指点.html","preview":"\u003cp\u003e大学时期在V2上遇到的一个大牛给的指点，非常中肯，对于学生时代的我又很大的帮助，非常感谢 v2exer Feiox\u003c/p\u003e\n","title":"V2EX大牛的指点"}]